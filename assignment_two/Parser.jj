/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * Example template taken from Appel's book.
 */

/*****************************
 **** SECTION 1 - OPTIONS ****
 *****************************/

options { 
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
  LOOKAHEAD = 2;
  DEBUG_PARSER = true;
}


/*******************************
 **** SECTION 2 - USER CODE ****
 *******************************/

PARSER_BEGIN(Parser)
  public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
    public static void main(String args[]) {
      Parser parser = null;

      if(args.length == 0) {
        System.out.println("Reading from standard input . . .");
        parser = new Parser(System.in);
      } else if(args.length == 1) {
        try {
          parser = new Parser(new java.io.FileInputStream(args[0]));
        } catch (java.io.FileNotFoundException e) {
          System.err.println("File " + args[0] + " not found.");
          return;
        }
      } else {
        System.out.println("Parser: Usage is one of:");
        System.out.println("\tjava Parser < inputfile");
        System.out.println("OR");
        System.out.println("\tjava Parser inputfile");
      }

      // Parser is now ready for input.
      try {
        SimpleNode root = parser.program();
        System.out.println("Program parsed successfully.");
        root.dump("");
      } catch (ParseException e) {
        System.out.println(e.getMessage());
        System.out.println("Parser encountered errors during parse.");
      }
    }
  }
PARSER_END(Parser)

/***************************************
 **** SECTION 3 - TOKEN DEFINITIONS ****
 ***************************************/

TOKEN_MGR_DECLS : {
  // Incremented or decremented depending on how deep our current level of
  // nested comments are.
  static int commentDepth = 0;
}

// The regexes that if matched will just be skipped.
SKIP : {
  // Single line comments handled here.
  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| " "
| "\t"
| "\n"
}

SKIP : {
  // Multi-line comments handled here.
  "/*" { commentDepth++; } : IN_COMMENT
}

<IN_COMMENT> SKIP: {
  "/*" { commentDepth++; }
| "*/" { commentDepth--;
          if(commentDepth == 0)
            SwitchTo(DEFAULT);
       }
| <~[]>
}

// For the regex on the right, the token on the left is generated.
// Language reserved words.
TOKEN : {
  <BEGIN: "begin">
| <END: "end">
| <MAIN: "main">
| <VAR: "var">
| <CONST: "const">
| <RETURN: "return">
| <INTEGER: "integer">
| <BOOLEAN: "boolean">
| <VOID: "void">
| <IF: "if">
| <ELSE: "else">
| <TRUE: "true">
| <FALSE: "false">
| <WHILE: "while">
| <IS: "is">
| <SKIP_TOKEN: "SKIP">
}

// Symbol tokens.
TOKEN : {
  <COMMA: ",">
| <SEMIC: ";">
| <COLON: ":">
| <EQUALS: "=">
| <LB: "(">
| <RB: ")">
| <PLUS: "+">
| <MINUS: "-">
| <TILDE: "~">
| <OR: "||">
| <AND: "&&">
| <LOGICAL_EQ: "==">
| <NOT_EQ: "!=">
| <LT: "<">
| <LT_EQ: "<=">
| <GT: ">">
| <GT_EQ: ">=">
}


TOKEN : {
  // NUM must start with a positive digit or a negative symbol followed by
  // a positive digit.
  <NUM: ( (["1"-"9"]((<DIGIT>)*))
        | ("-"["1"-"9"]((<DIGIT>)*))
        | "0" )>
| <ID: ((<CHAR>)+(<CHAR> | <NUM> | ["_"])*)>
| <#DIGIT: ["0"-"9"]>
| <#CHAR: ["a"-"z"]|["A"-"Z"]>
}

TOKEN : {
  <OTHER: ~[]>
}


/****************************************************************
 **** SECTION 4 - GRAMMAR AND PRODUCTION RULES - NOT NEEDED. ****
 ****************************************************************/

SimpleNode program()       : {/*@bgen(jjtree) Prog */
  SimpleNode jjtn000 = new SimpleNode(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Prog */
  try {
/*@egen*/
  declList() functionList() main() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void declList()      : {} {
  nempDeclList()
|
  emptyDeclList()
}

void nempDeclList()          : {/*@bgen(jjtree) DeclList */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) DeclList */
  try {
/*@egen*/
  (decl())+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void emptyDeclList()               : {/*@bgen(jjtree) EmptyDeclList */
  SimpleNode jjtn000 = new SimpleNode(JJTEMPTYDECLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) EmptyDeclList */
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl()       : {} {
  varDecl() | constDecl()
}

void varDecl()          : {/*@bgen(jjtree) VarDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) VarDecl */
  try {
/*@egen*/
  <VAR> id() <COLON> type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void id()     : {/*@bgen(jjtree) ID */
  SimpleNode jjtn000 = new SimpleNode(JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ID */
  try {
/*@egen*/
  <ID>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type()       : {} {/*@bgen(jjtree) IntType */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTINTTYPE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/         
|/*@bgen(jjtree) BoolType */
  {
    SimpleNode jjtn002 = new SimpleNode(JJTBOOLTYPE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ 
  <BOOLEAN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/          
|/*@bgen(jjtree) VoidType */
  {
    SimpleNode jjtn003 = new SimpleNode(JJTVOIDTYPE);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
  }
  try {
/*@egen*/
  <VOID>/*@bgen(jjtree)*/
  } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
    }
  }
/*@egen*/          
}

void constDecl()            : {/*@bgen(jjtree) ConstDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ConstDecl */
  try {
/*@egen*/
  <CONST> id() <COLON> type() <EQUALS> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void functionList()               : {/*@bgen(jjtree) FunctionList */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) FunctionList */
  try {
/*@egen*/
  (function() functionList())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function()           : {/*@bgen(jjtree) Function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Function */
  try {
/*@egen*/
  type() <ID> <LB> paramList() <RB> <IS>
  declList()
  <BEGIN>
  statementBlock()
  <RETURN> <LB> (expression())? <RB> <SEMIC>
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void paramList()            : {/*@bgen(jjtree) ParamList */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ParamList */
  try {
/*@egen*/
  (nempParamList())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nempParamList()                : {/*@bgen(jjtree) NempParamList */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) NempParamList */
  try {
/*@egen*/
  (<ID> <COLON> type()) (<COMMA> <ID> <COLON> type())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void main()       : {/*@bgen(jjtree) Main */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Main */
  try {
/*@egen*/
  <MAIN>
  <BEGIN>
  declList()
  statementBlock()
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statementBlock()       : {} {
  nempStatementBlock()
|
  emptyStatementBlock()
}

void emptyStatementBlock()                      : {/*@bgen(jjtree) EmptyStatementBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTEMPTYSTATEMENTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) EmptyStatementBlock */
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nempStatementBlock()                 : {/*@bgen(jjtree) StatementBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) StatementBlock */
  try {
/*@egen*/
  (statement())+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement()       : {} {
  (assign_statement() | statement_function_call()) <SEMIC>
| 
  scope_block()
|
  if_statement()
|
  while_statement()
|
  empty_statement()
}

void scope_block()             : {/*@bgen(jjtree) ScopeBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSCOPEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ScopeBlock */
  try {
/*@egen*/
  <BEGIN> statementBlock() <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void if_statement()              : {/*@bgen(jjtree) IfStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  <IF> condition() <BEGIN> statementBlock() <END> <ELSE> <BEGIN> statementBlock() <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void while_statement()                 : {/*@bgen(jjtree) WhileStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  <WHILE> condition() <BEGIN> statementBlock() <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void empty_statement()                 : {/*@bgen(jjtree) EmptyStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) EmptyStatement */
  try {
/*@egen*/
  <SKIP_TOKEN> <SEMIC>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement_function_call()                    : {/*@bgen(jjtree) FunctionStatement */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) FunctionStatement */
  try {
/*@egen*/
  id() <LB> argList() <RB>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void assign_statement()         : {/*@bgen(jjtree) Assign */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Assign */
  try {
/*@egen*/
  id() <EQUALS> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void expression()       : {} {
  (<LB> expression() <RB>)
|
  (negative_id() | num() | trueVal() | falseVal()) (binaryArithOp())
|
  (<ID> expression_id())
}

void negative_id()           : {/*@bgen(jjtree) Negative */
  SimpleNode jjtn000 = new SimpleNode(JJTNEGATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Negative */
  try {
/*@egen*/
  <MINUS> id()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void num()      : {/*@bgen(jjtree) Num */
  SimpleNode jjtn000 = new SimpleNode(JJTNUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Num */
  try {
/*@egen*/
  <NUM>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void trueVal()       : {/*@bgen(jjtree) True */
  SimpleNode jjtn000 = new SimpleNode(JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) True */
  try {
/*@egen*/
  <TRUE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void falseVal()        : {/*@bgen(jjtree) False */
  SimpleNode jjtn000 = new SimpleNode(JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) False */
  try {
/*@egen*/
  <FALSE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * Function Args
 * OR
 * binArithOp + expression
 * OR
 * {}
 */
void expression_id()       : {} {/*@bgen(jjtree) FuncCall */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTFUNCCALL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (<LB> argList() <RB>)/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/          
| (binaryArithOp())
|/*@bgen(jjtree) ID */
  {
    SimpleNode jjtn002 = new SimpleNode(JJTID);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn002, true);
    jjtc002 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/    
}

void binaryArithOp()       : {} {/*@bgen(jjtree) Add */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTADD);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (<PLUS> expression())/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/     
|/*@bgen(jjtree) Subtract */
  {
    SimpleNode jjtn002 = new SimpleNode(JJTSUBTRACT);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ 
  (<MINUS> expression())/*@bgen(jjtree)*/
  } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      throw (RuntimeException)jjte002;
    }
    if (jjte002 instanceof ParseException) {
      throw (ParseException)jjte002;
    }
    throw (Error)jjte002;
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/          
}

void condition()            : {/*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Condition */
  try {
/*@egen*/
  (<TILDE> condition() condition_prime())
| (<LB> condition() <RB> condition_prime())
| (<ID> expression_id() compOpp() expression() condition_prime())
| (((negative_id() | num() | trueVal() | falseVal()) (binaryArithOp())) compOpp() expression() condition_prime())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void condition_prime()                 : {/*@bgen(jjtree) ConditionPrime */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ConditionPrime */
  try {
/*@egen*/
  (orAndRule() condition() condition_prime())
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void orAndRule()            : {/*@bgen(jjtree) OrAndRule */
  SimpleNode jjtn000 = new SimpleNode(JJTORANDRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) OrAndRule */
  try {
/*@egen*/
  <OR> | <AND>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void compOpp()          : {/*@bgen(jjtree) CompOpp */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPOPP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) CompOpp */
  try {
/*@egen*/
  <LOGICAL_EQ>
| <NOT_EQ>
| <LT>
| <LT_EQ>
| <GT>
| <GT_EQ>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void argList()          : {/*@bgen(jjtree) ArgList */
  SimpleNode jjtn000 = new SimpleNode(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ArgList */
  try {
/*@egen*/
  (nempArgList())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nempArgList()              : {/*@bgen(jjtree) NempArgList */
  SimpleNode jjtn000 = new SimpleNode(JJTNEMPARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) NempArgList */
  try {
/*@egen*/
  (<ID> (<COMMA> <ID>)*)/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}